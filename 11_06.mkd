Linux
====
Automake, Autotools

    reducer_dist_LDFLAGS=-static-libtool-libs   # Makefile.am
    --enable-static --enable-profile --enable-debug --disable-optimize

autoconf copies the contents of 'configure.in' to 'configure', expanding macros
as they occur in the input.


Make. Target rules start at the beginning of a line and are followed by a colon.
Following the colon is a whitespace separated list of dependencies. A series of
lines follow which contain shell commands to be run by a sub-shell. Each of
these lines must be prefixed by a horizontal tab character.

These commands may be prefixed by an '@' character to prevent make from echoing
the command line prior to executing it. 

They may also optionally be prefixed by a '-' character to allow the rule to
continue if the command returns a non-zero exit code.

`$@` represent the names of the target

`$<` the first dependency 

    $ cat Makefile
    all: dummy
        @echo "$@ depends on dummy"
    dummy:
        touch $@
    $ make
    touch dummy
    all depends on dummy

Makefile's suffix rule:

    $.c.o:
        $(CC) $(CFLAGS) -c $< -o $@

Unless a more specific rule matches the target being sought, this rule will
match any target that ends in '.o'. These files are said to always be dependent
on '.c'. 
Linux
====
Useful commands:

    $ shopt -s extglob
    $ mkdir ~/.vim/{plugin,doc,syntax} -p
    $ help shopt    # set shell option
    $ arch          # view machine arch
    $ uname         # view system info
    $ hostname
    $ dd            # convert and format data
    $ od -An -j4 -N4 -t 4d  # view binary data
    $ hexdump -n 16 -s [byte_to_skip] -e '4/4 "%d\n"' bin
    $ help compgen  # complete, autocomplete bash, complete globbing

GDB, set exec-wrapper wrapper. When 'exec-wrapper' is set, the specified wrapper
is used to launch programs for debugging. gdb starts your program with a shell
command of the form exec wrapper program. Quoting is added to program and its
arguments, but not to wrapper, so you should add quotes if appropriate for your
shell. The wrapper runs until it executes your program, and then gdb takes
control.

You can use any program that eventually calls execve with its arguments as a
wrapper. Several standard Unix utilities do this, e.g. env and nohup. Any Unix
shell script ending with exec "$@" will also work.

For example, you can use env to pass an environment variable to the debugged
program, without setting the variable in your shell's environment:

    (gdb) set exec-wrapper env 'LD_PRELOAD=libtest.so'
    (gdb) run
    (gdb) where     # where
    (gdb) finish    # finish

SVN add external package dependency

    $ svn propedit svn:externals 

Program information, linker and loader

    $ ldd *.so
    $ nm *.obj
    $ ranlib archive
    $ ar archive
    /etc/ld.so.cache
    ldconfig

Vim
====
Vim windows

    $ vim -O file1 file2    # split window vertically
    $ vim -o file1 file2    # split window horizontally
    $ vimdiff -o file1 file2

    CTRL-W s    
    :sp
    CTRL-W v
    :vs
    CTRL-W n
    :new
    CTRL-W j    # move cursor to window below
    CTRL-W k    # move cursor to window above
    CTRL-W h    # move cursor to window left
    CTRL-W l    # move cursor to window right
    CTRL-W t    # move cursor to top-left window
    CTRL-W b    # move cursor to bottom-right window
    CTRL-W p    # go to previsou window
    CTRL-W o    # make current window the only one
    :hid        # quit current window
    :sv         # split and view (readonly)
    :sf {file}  # search for file in 'path' and split if found
    :h \_p      # any printable character including newline
    ;           # next f, F, t, T command
    ,           # next f, F, t, T command in opposite direction
    @:          # next command-mode command
    CTRL-a      # inc number
    CTRL-x      # dec number
    *,#         # find word under cursor
    ["x]S       # delete [into register x] and start insert, same to cc
    gD          # go to global definition
    C-d, C-t    # indent in insert mode, very useful
    C-w         # delete previous word in insert mode
Linux
====
get largest line length

    $ wc -L file

set temporary directory of sort

    $ sort -T ~/tmp
    $ export TMPDIR=~/tmp

Java 
====
A static nested class interacts with the instance members of its outer
class (and other classes) just like any other top-level class. In effect, a
static nested class is behaviorally a top-level class that has been nested in
another top-level class for packaging convenience. 




English
====
That is both a blessing and a curse since you can, in essence, violate the
encapsulation of the outer class by *mucking up* the outer class's protected and
private fields. 

If something is *slated*, it is criticized very severely.


Pig
====
see org.apache.pig.builtin.TOP
script.pig: 

    register /home/ime/chenming/pig/imeudf.jar;
    a = load '/ime/javier/dbg_sample_wrongdata/201105' using PigStorage(' '); 
    b = stream a through `gawk 'NF==9'` as (date, time, py:chararray, hz, exe,
            num, type:chararray, adj:chararray, err:int);
    c = filter b by err==-1;
    d = group c by hz; 
    e = foreach d generate group, COUNT(c), 
        com.sogou.imeresearch.udf.ImeDistinct(c.py);
    store e into '/ime/javier/testpig2';

ImeDistinct.java:

    package com.sogou.imeresearch.udf;
    import java.io.IOException;

    /**
     * Count distinct tuples in a bag.
     */
    public class ImeDistinct extends EvalFunc<DataBag> implements Algebraic {
        public static Long one = Long.valueOf(1);
        private static BagFactory bagFactory = BagFactory.getInstance();
        private static TupleFactory tupleFactory = TupleFactory.getInstance();
        /* (non-Javadoc)
         * @see org.apache.pig.EvalFunc#exec(org.apache.pig.data.Tuple)
         */
        @Override
        public DataBag exec(Tuple input) throws IOException {
            return getDistinct(input);
        }

        /* (non-Javadoc)
         * @see org.apache.pig.Algebraic#getFinal()
         */
        @Override
        public String getFinal() {
            return Final.class.getName();
        }

        /* (non-Javadoc)
         * @see org.apache.pig.Algebraic#getInitial()
         */
        @Override
        public String getInitial() {
            return Initial.class.getName();
        }

        /* (non-Javadoc)
         * @see org.apache.pig.Algebraic#getIntermed()
         */
        @Override
        public String getIntermed() {
            return Intermediate.class.getName();
        }

        static public class Initial extends EvalFunc<Tuple> {
            /* (non-Javadoc)
             * @see org.apache.pig.EvalFunc#exec(org.apache.pig.data.Tuple)
             */
            @Override
            public Tuple exec(Tuple input) throws IOException {
                // the input has  a single field which is a tuple
                // representing the data we want to distinct. 
                // unwrap, put in a bag and send down
                try {
                    DataBag outputBag = bagFactory.newDefaultBag();
                    DataBag inputBag = (DataBag) input.get(0);
                    
                    for (Tuple inTp : inputBag) {
                        Tuple outTp = tupleFactory.newTuple(2);
                        outTp.set(0, inTp.get(0));
                        outTp.set(1, one);
                        outputBag.add(outTp);
                    }
                    
                    return tupleFactory.newTuple(outputBag);
                } catch (ExecException e) {
                    throw e;
                }
            }
        }

        static public class Intermediate extends EvalFunc<Tuple> {
            /* (non-Javadoc)
             * @see org.apache.pig.EvalFunc#exec(org.apache.pig.data.Tuple)
             */
            @Override
            public Tuple exec(Tuple input) throws IOException {
                return tupleFactory.newTuple(countDistinct(input, this));
            }
        }

        static public class Final extends EvalFunc<DataBag> {
            /* (non-Javadoc)
             * @see org.apache.pig.EvalFunc#exec(org.apache.pig.data.Tuple)
             */
            @Override
            public DataBag exec(Tuple input) throws IOException {
                return countDistinct(input, this);
            }
        }
        
        static private DataBag createDataBag() {
            // by default, we create InternalSortedBag, unless user configures
            // explicitly to use old bag
            String bagType = null;
            if (PigMapReduce.sJobConfInternal.get() != null) {     
                bagType = PigMapReduce.sJobConfInternal.get().get(
                        "pig.cachedbag.distinct.type");       			
            }
                          
            if (bagType != null && bagType.equalsIgnoreCase("default")) {
                return BagFactory.getInstance().newDistinctBag();
            } else {   	    	
                return new InternalDistinctBag(3);
            }
        }
        
        static private DataBag countDistinct(Tuple input, EvalFunc evalFunc) 
                throws IOException {
            DataBag outputBag = createDataBag();
            long progressCounter = 0;
            Map<Object, Long> map = new HashMap<Object, Long>();
            DataBag inputBag = (DataBag)input.get(0);
            try {
                for (Tuple tuple : inputBag) {
                    for (Tuple t : (DataBag)tuple.get(0)) {
                        Object key = (Object)t.get(0);
                        Long val = (Long)t.get(1);
                        if (map.containsKey(key)) {
                            val += map.get(key);
                        }
                        map.put(key, val);
                        ++progressCounter;
                        if((progressCounter % 1000) == 0){
                            evalFunc.progress();
                        }
                    }
                }
                for (Object key : map.keySet()) {
                    Tuple tp = tupleFactory.newTuple(2);
                    tp.set(0, key);
                    tp.set(1, map.get(key));
                    outputBag.add(tp);
                }
            } catch (ExecException e) {
                throw e;
            }
            return outputBag;
        }

        protected DataBag getDistinct(Tuple input) throws IOException {
            try {
                DataBag inputBg = (DataBag)input.get(0);
                DataBag result = createDataBag();
                Map<Object, Long> map = new HashMap<Object, Long>();
                long progressCounter = 0;
                for (Tuple tuple : inputBg) {
                    Object key = (Object)tuple.get(0);
                    Long val = one;
                    if (map.containsKey(key)) {
                        val += map.get(key);
                    }
                    map.put(key, val);
                    ++progressCounter;
                    if ((progressCounter % 1000) == 0) {
                        progress();
                    }
                }
                for (Object key : map.keySet()) {
                    Tuple tp = tupleFactory.newTuple(2);
                    tp.set(0, key);
                    tp.set(1, map.get(key));
                    result.add(tp);
                }
                return result;
            } catch (ExecException e) {
                 throw e;
            }
        }
    }
